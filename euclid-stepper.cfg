#  |
#  |                                * Probe Ready Position
#  |                                  X150 Y150
#  |
#  | â€¦
#  |
#  | * Dock Re-entry staging  position
#  |   X0 Y70
#  |
#  |
#  | * Dock Exit Position
#  |   X0 Y40
#  |
#  |
#  |
#  |
#  |
#  |   X0 Y0    X30 Y0       X100 Y0
#  | * Dock   * Dock Side  * Dock Preflight
#  |_____________________________________________________________
#
# With the coupling magnets +/- 2mm of the nozzle the probe trigger height is on
# the order of 12mm, so 15mm is used as a safe height.

[gcode_macro EuclidProbe]
description: config vars for Euclid probe deploy/stow

## how much space to put between the bed and nozzle for homing
variable_bed_clearance: 15

## where to put the probe during deployment steps
variable_position_side:      [ 398, 25 ]
variable_position_dock:      [ 378, 25 ]
## exit/re-entry staging
variable_position_exit:      [ 378, 75 ]

# 300 * 60
variable_move_speeds: 18000

variable_batch_mode_enabled: False
variable_probe_state: None

variable_stepper_extend_angle: 92
variable_stepper_retract_angle: 0

gcode:
    RESPOND TYPE=command MSG="{ printer['gcode_macro EuclidProbe'] }"

[tmc2209 manual_stepper euclid_dock]
uart_pin: e_uart_pin # PC6
run_current: 0.05
stealthchop_threshold: 999999
interpolate: False

## sensorless homing config; ref https://github.com/Klipper3d/klipper/issues/2563
## never got it to work :-(
# diag_pin: PG10 # DIAG2
# driver_SGTHRS: 96

[manual_stepper euclid_dock]
## using extruder stepper driver from pre-toolboard times, aka DRIVER2
step_pin: e_step_pin # PF11
dir_pin: !e_dir_pin # PG3
enable_pin: !e_enable_pin # PG5
microsteps: 64

#> rotation_distance is the amount of distance that the axis moves with one full
#> revolution of the stepper motor
## I want to treat the distance as an angle, so setting the rotation_distance to
## 360 should do that.
rotation_distance: 360

velocity: 1440
#   Set the default velocity (in mm/s) for the stepper. This value
#   will be used if a MANUAL_STEPPER command does not specify a SPEED
#   parameter. The default is 5mm/s.
accel: 7500
#   Set the default acceleration (in mm/s^2) for the stepper. An
#   acceleration of zero will result in no acceleration. This value
#   will be used if a MANUAL_STEPPER command does not specify an ACCEL
#   parameter. The default is zero.

## sensorless homing
; endstop_pin: tmc2209_euclid_dock:virtual_endstop
#   Endstop switch detection pin. If specified, then one may perform
#   "homing moves" by adding a STOP_ON_ENDSTOP parameter to
#   MANUAL_STEPPER movement commands.

## home the dock stepper on startup
[delayed_gcode euclid_home_dock_stepper]
initial_duration: 1
gcode:
    {% set euclid_probe = printer["gcode_macro EuclidProbe"] %}

    ## home dock stepper; bed WILL hit probe dock, given the chance!
    MANUAL_STEPPER STEPPER=euclid_dock SET_POSITION={ euclid_probe.stepper_extend_angle + 5 }
    MANUAL_STEPPER STEPPER=euclid_dock MOVE={ euclid_probe.stepper_retract_angle } SPEED=180

[probe]
pin: ^PG15

## z-probe pin position:
##
##  probe: 28.70, 15.10
##  nozzle: 0.60, -2.10
##
##  offset: -28.1, -17.2

x_offset: -30
y_offset: -21

## if live-z is positive, subtract from z_offset
; z_offset: 8.472
z_offset: 8.507

speed: 5                     ; probing speed of 5mm/second ideal is <10mm/sec
lift_speed: 30
samples: 2                   ; number of probes to perform per sample
samples_result: average      ; normalization method: see config reference
sample_retract_dist: 5.0
samples_tolerance: 0.050
samples_tolerance_retries: 3

[homing_override]
axes: z
set_position_z: -5
gcode:
    {% set euclid_probe = printer["gcode_macro EuclidProbe"] %}

    G90

    ;; force bed to move down
    SET_KINEMATIC_POSITION Z=0
    G0 Z{ euclid_probe.bed_clearance } F500

    ;; home Y and X, Y first to avoid running into the dock
    {% if "y" not in (printer.toolhead.homed_axes | lower) %}
        G28 Y
    {% endif %}

    {% if "x" not in (printer.toolhead.homed_axes | lower) %}
        G28 X
    {% endif %}

    DEPLOY_PROBE

    ;; home Z at bed center
    G0 X{ printer.toolhead.axis_maximum.x/2 } Y{ printer.toolhead.axis_maximum.y/2 } F{ euclid_probe.move_speeds }
    G28 Z

    ;; after 'G28 Z' the probe stays in contact with the bed; move it away.
    G0 Z{ euclid_probe.bed_clearance }

    STOW_PROBE

[gcode_macro _ASSERT_PROBE_STATE]
description: ensures probe is in a known state; QUERY_PROBE must have been called before this macro!
gcode:
    ## QUERY_PROBE manually-verified results, when microswitch not depressed
    ## "TRIGGERED" -> 1 :: probe stowed
    ## "open"      -> 0 :: probe deployed
    {% set last_query_state = "stowed" if printer.probe.last_query == 1 else "deployed" %}

    {% if params.MUST_BE != last_query_state %}
        { action_raise_error("expected probe state to be {} but is {} ({})".format(params.MUST_BE, last_query_state, printer.probe.last_query)) }
    {% else %}
        ## all good; update state
        SET_GCODE_VARIABLE MACRO=EuclidProbe VARIABLE=probe_state VALUE="'{ last_query_state }'"
    {% endif %}

[gcode_macro ASSERT_PROBE_DEPLOYED]
description: error if probe not deployed
gcode:
    ; wait for moves to finish, then pause 0.25s for detection
    M400
    G4 P250

    QUERY_PROBE
    _ASSERT_PROBE_STATE MUST_BE=deployed

[gcode_macro ASSERT_PROBE_STOWED]
description: error if probe not stowed
gcode:
    ; wait for moves to finish, then pause 0.25s for detection
    M400
    G4 P250

    QUERY_PROBE
    _ASSERT_PROBE_STATE MUST_BE=stowed

[gcode_macro EUCLID_PROBE_BEGIN_BATCH]
description: begin euclid probe batch mode
gcode:
    SET_GCODE_VARIABLE MACRO=EuclidProbe VARIABLE=batch_mode_enabled VALUE=True
    RESPOND TYPE=command MSG="Probe batch mode enabled"

[gcode_macro EUCLID_PROBE_END_BATCH]
description: end euclid probe batch mode and stow probe
gcode:
    SET_GCODE_VARIABLE MACRO=EuclidProbe VARIABLE=batch_mode_enabled VALUE=False
    RESPOND TYPE=command MSG="Probe batch mode disabled"
    STOW_PROBE

[gcode_macro EUCLID_PROBE_EXTEND_DOCK]
description: extends the euclid probe dock
gcode:
    {% set euclid_probe = printer["gcode_macro EuclidProbe"] %}

    MANUAL_STEPPER STEPPER=euclid_dock MOVE={ euclid_probe.stepper_extend_angle }
    M400

[gcode_macro EUCLID_PROBE_RETRACT_DOCK]
description: retracts the euclid probe dock
gcode:
    {% set euclid_probe = printer["gcode_macro EuclidProbe"] %}

    ; retract the dock
    MANUAL_STEPPER STEPPER=euclid_dock MOVE={ euclid_probe.stepper_retract_angle }
    M400
    MANUAL_STEPPER STEPPER=euclid_dock ENABLE=0


[gcode_macro DEPLOY_PROBE]
description: deploy Euclid probe
gcode:
    {% set euclid_probe = printer["gcode_macro EuclidProbe"] %}

    {% if euclid_probe.batch_mode_enabled and euclid_probe.probe_state == "deployed" %}
        ; RESPOND TYPE=command MSG="Probe batch mode enabled: already deployed"
        G4 P0
    {% else %}
        RESPOND TYPE=command MSG="Deploying probe"

        ; ensure the probe is currently stowed; can't deploy what isn't stowed.
        ASSERT_PROBE_STOWED

        G90

        ; set approach elevation to clear probe over bed on fixed gantry machine
        G0 Z{ euclid_probe.bed_clearance } F500

        ;  move to the side of the dock
        G0 X{ euclid_probe.position_side[0] } Y{ euclid_probe.position_side[1] } F{ euclid_probe.move_speeds }

        ; wait 1/4 second
        M400
        G4 P250

        EUCLID_PROBE_EXTEND_DOCK

        ;  move sideways over the dock to pick up probe
        G0 X{ euclid_probe.position_dock[0] } Y{ euclid_probe.position_dock[1] } F1500

        ; confirm deploy was successful
        ASSERT_PROBE_DEPLOYED

        ; move out of the dock in a straight line
        G0 X{ euclid_probe.position_exit[0] } Y{ euclid_probe.position_exit[1] } F{ euclid_probe.move_speeds }

        EUCLID_PROBE_RETRACT_DOCK
    {% endif %}

[gcode_macro STOW_PROBE]
description: stow Euclid probe
gcode:
    {% set euclid_probe = printer["gcode_macro EuclidProbe"] %}

    {% if euclid_probe.batch_mode_enabled %}
        ; RESPOND TYPE=command MSG="Probe batch mode enabled: not stowing"
        G4 P0
    {% else %}
        RESPOND TYPE=command MSG="Stowing probe"

        ; ensure the probe is currently deployed; can't stow what isn't deployed.
        ASSERT_PROBE_DEPLOYED

        G90

        ; set approach elevation for fixed gantry system to clear probe over bed
        G0 Z{ euclid_probe.bed_clearance } F3000

        ; move to the exit/re-entry staging position
        G0 X{ euclid_probe.position_exit[0] } Y{ euclid_probe.position_exit[1] } F{ euclid_probe.move_speeds }
        M400

        EUCLID_PROBE_EXTEND_DOCK

        ; slowly move into dock
        G0 X{ euclid_probe.position_dock[0] } Y{ euclid_probe.position_dock[1] } F3000

        ; wait for moves to finish, pause to force 90deg travel swipe
        M400
        G4 P250

        ; quick swipe off
        G0 X{ euclid_probe.position_side[0] } Y{ euclid_probe.position_side[1] } F{ euclid_probe.move_speeds }

        ; confirm stowing was successful
        ASSERT_PROBE_STOWED

        EUCLID_PROBE_RETRACT_DOCK
    {% endif %}


; # Macro to perform a bed mesh calibration by wrapping it in DEPLOY_PROBE/STOW_PROBE macros
; [gcode_macro BED_MESH_CALIBRATE]
; rename_existing: BED_MESH_CALIBRATE_ORIG
; gcode:
;     DEPLOY_PROBE
;     BED_MESH_CALIBRATE_ORIG
;     STOW_PROBE

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BED_MESH_CALIBRATE_ORIG

variable_buffer: 20

gcode:
    {% set start_print  = printer["gcode_macro START_PRINT"] %}
    {% set bed_mesh     = printer.configfile.settings.bed_mesh %}
    {% set probe_config = printer.configfile.settings.probe %}

    {% if start_print.first_layer_min_xy and start_print.first_layer_max_xy %}
        { action_respond_info("print_min: {}".format(start_print.first_layer_min_xy)) }
        { action_respond_info("print_max: {}".format(start_print.first_layer_max_xy)) }

        {% set print_min_x = (start_print.first_layer_min_xy[0] | float) + probe_config.x_offset %}
        {% set print_min_y = (start_print.first_layer_min_xy[1] | float) + probe_config.y_offset %}
        {% set print_max_x = (start_print.first_layer_max_xy[0] | float) - probe_config.x_offset %}
        {% set print_max_y = (start_print.first_layer_max_xy[1] | float) - probe_config.y_offset %}

        DEPLOY_PROBE

        {% if (print_min_x < print_max_x) and (print_min_y < print_max_y) %}

            {% set minimum_probe_count = 5 if bed_mesh.algorithm == "bicubic" else 3 %}

            # bed_mesh.probe_count is a tuple
            {% set probe_count = bed_mesh.probe_count %}
            {% set probe_count_x = probe_count[0] %}
            {% set probe_count_y = probe_count[1] if (probe_count | length) == 2 else probe_count_x %}

            # -1 is the effective, undocumented default
            {% set relative_reference_index = bed_mesh.relative_reference_index | default(-1, true) %}
            {% set mesh_min_x, mesh_min_y = bed_mesh.mesh_min %}
            {% set mesh_max_x, mesh_max_y = bed_mesh.mesh_max %}

            # If print area X is smaller than 50% of the bed size, use the
            # minimum probe count for X instead of the default
            {% if (print_max_x - print_min_x) < (mesh_max_x - mesh_min_x)/2 %}
                {% set probe_count_x = minimum_probe_count %}
            {% endif %}

            # If print area Y is smaller than 50% of the bed size, use the
            # minimum probe count for Y instead of the default
            {% if (print_max_y - print_min_y) < (mesh_max_y - mesh_min_y)/2 %}
                {% set probe_count_y = minimum_probe_count %}
            {% endif %}

            {% if relative_reference_index > 0 %}
                {% set relative_reference_index = ((probe_count_x * probe_count_y - 1) / 2)|int %}
            {% endif %}

            {% set mesh_min_x = [print_min_x - buffer, mesh_min_x] | max %}
            {% set mesh_min_y = [print_min_y - buffer, mesh_min_y] | max %}
            {% set mesh_max_x = [print_max_x + buffer, mesh_max_x] | min %}
            {% set mesh_max_y = [print_max_y + buffer, mesh_max_y] | min %}

            { action_respond_info("mesh_min: ({}, {})".format(mesh_min_x, mesh_min_y)) }
            { action_respond_info("mesh_max: ({}, {})".format(mesh_max_x, mesh_max_y)) }
            { action_respond_info("probe_count: ({}, {})".format(probe_count_x,probe_count_y)) }
            { action_respond_info("relative_reference_index: {}".format(relative_reference_index)) }

            BED_MESH_CALIBRATE_ORIG mesh_min={mesh_min_x},{mesh_min_y} mesh_max={mesh_max_x},{mesh_max_y} probe_count={probe_count_x},{probe_count_y} relative_reference_index={relative_reference_index}

        {% else %}
            BED_MESH_CALIBRATE_ORIG
        {% endif %}

        STOW_PROBE

    {% else %}
        DEPLOY_PROBE

        BED_MESH_CALIBRATE_ORIG

        STOW_PROBE
    {% endif %}

# Macro to perform a modified z_tilt by wrapping it in DEPLOY_PROBE/STOW_PROBE macros
[gcode_macro Z_TILT_ADJUST]
rename_existing: Z_TILT_ADJUST_ORIG
gcode:
    DEPLOY_PROBE
    Z_TILT_ADJUST_ORIG
    STOW_PROBE
